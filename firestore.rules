/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All data is
 * considered private and is scoped directly to the authenticated user who created it.
 * Access to another user's data is explicitly forbidden.
 *
 * Data Structure: All application data is nested under the `/users/{userId}` path.
 * This top-level document stores the user's profile, and all other user-specific data,
 * such as disease detection history and chat history, are stored in subcollections
 * within this user-specific data tree.
 *
 * Key Security Decisions:
 * - User Isolation: A user can only ever read or write data within their own
 *   document tree (i.e., `/users/{request.auth.uid}/...`).
 * - No User Listing: It is not possible to query the top-level `/users` collection.
 *   This prevents users from discovering other users in the system.
 * - Profile Deletion Disabled: User profile documents (`/users/{userId}`) cannot be
 *   deleted directly by the client to prevent accidental data loss. This should be
 *   handled by a trusted server-side process if needed.
 *
 * Denormalization for Authorization: The security model relies on path-based
 * authorization. The `userId` in the document path is the sole source of truth for
 * ownership. Subcollections contain a denormalized `userId` field, which is validated
 * against the path to ensure relational integrity without requiring extra `get()` calls.
 *
 * Structural Segregation: User-specific data (`diseaseHistory`, `chatHistory`) is
 * segregated into distinct subcollections under the user's main document. This
 * enforces clear security boundaries and simplifies rules, as all documents within a
 * given subcollection path share the same ownership-based access controls.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    // ------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the given userId.
     * This is the primary function for establishing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document. Used for update and delete
     * operations to ensure the target document exists before the operation.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * On create, validates that the incoming document's 'id' field matches the
     * user's UID. This enforces relational integrity for the user profile document.
     */
    function isCreatingOwnUserDoc(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * On update, ensures the user's 'id' field cannot be changed.
     */
    function isImmutableUserId() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * On create, validates that a subcollection document's 'userId' field
     * correctly references the parent user document.
     */
    function hasCorrectUserId(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * On update, ensures that a subcollection document's 'userId' field
     * cannot be changed, preserving the ownership link.
     */
    function hasImmutableParentUserId() {
      return request.resource.data.userId == resource.data.userId;
    }


    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow (create) An authenticated user can create their own profile document.
     * @allow (get, update) An authenticated user can read and modify their own profile.
     * @deny (list) Listing all user profiles is explicitly forbidden for security.
     * @deny (get, update, delete) A user cannot access or delete another user's profile.
     * @principle Restricts access to a user's own data tree and enforces self-creation.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && isCreatingOwnUserDoc(userId);
      allow update: if isExistingOwner(userId) && isImmutableUserId();
      allow delete: if false;

      /**
       * @description Manages a user's private disease detection history records.
       * @path /users/{userId}/diseaseHistory/{diseaseHistoryId}
       * @allow (create, get, list, update, delete) A user can fully manage their own disease history records.
       * @deny (any) A user cannot access another user's disease history in any way.
       * @principle Enforces strict ownership for a user's private subcollection data.
       */
      match /diseaseHistory/{diseaseHistoryId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasCorrectUserId(userId);
        allow update: if isExistingOwner(userId) && hasImmutableParentUserId();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Manages a user's private chat history with the AI.
       * @path /users/{userId}/chatHistory/{chatHistoryId}
       * @allow (create, get, list, update, delete) A user can fully manage their own chat history messages.
       * @deny (any) A user cannot access another user's chat history in any way.
       * @principle Enforces strict ownership for a user's private subcollection data.
       */
      match /chatHistory/{chatHistoryId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasCorrectUserId(userId);
        allow update: if isExistingOwner(userId) && hasImmutableParentUserId();
        allow delete: if isExistingOwner(userId);
      }
    }
  }
}